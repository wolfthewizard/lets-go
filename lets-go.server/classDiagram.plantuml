@startuml

namespace core {

    namespace interfaces {

        interface ICommandDirector {
            int CreateNewBotGame()
            int CreateNewMultiplayerGame()
            ResponseDTO TryToMove(MoveDTO: move)
            void CancelGame(int: leftPlayerId)
        }

        interface IMoveExecutorService {
            ResponseDTO: executeMove(MoveDTO: moveDTO)
        }

        interface IGameManagerService {
            void CreateNewGame(int: firstPlayerId)
            void CreateNewGame(int: firstPlayerId, int: secondPlayerId)
            void CancelGame(int: leftPlayerId)
        }

        interface IMoveValidator {
            boolean validateSuicide(Board: board, Move: move)
            boolean validateKO(Board: oldBoard, Board: currentBoard, Move: move)
            boolean validateVacant(Board: board, Move: move)
            ' mb more
        }

        interface IGameRepository {
            Game getGame(int playerId)
            void updateGameBoard(int, List<Change>)
        }
    }

    namespace services {

        class MoveExecutorService implements core.interfaces.IMoveExecutorService{
            -gameRepository : IGameRepository
            -moveValidator : MoveValidator

            +ResponseDTO executeMove(MoveDTO: moveDTO)
        }
        MoveExecutorService..>core.interfaces.IGameRepository
        MoveExecutorService..>core.interfaces.IMoveValidator

        class GameManagerService implements core.interfaces.IGameManagerService{
            -IGameRepository: gameRepository

            +void CreateNewGame(int: firstPlayerId)
            +void CreateNewGame(int: firstPlayerId, int: secondPlayerId)
            +void CancelGame(int: leftPlayerId)
        }
        GameManagerService..>core.interfaces.IGameRepository
    }

    class CommandDirector implements core.interfaces.ICommandDirector {
        -moveExecutorService : IMoveExecutorService
        -gameManagerService : IGameManagerService

        +int CreateNewBotGame()
        +int CreateNewMultiplayerGame()
        +ResponseDTO TryToMove(MoveDTO: move)
        +void CancelGame(int: leftPlayerId)
    }
    CommandDirector..>core.interfaces.IMoveExecutorService
    CommandDirector..>core.interfaces.IGameManagerService

    ' moze zamiast dzielic na 2 metody podzielimy na dwie klasy wtedy dwie referencje w executorze, albo jeszcze jednak klasa ktora to razem sklada taka mini facada
    class MoveValidator implements core.interfaces.IMoveValidator{
         +boolean validateSuicide(Board: board, Move: move)
         +boolean validateKO(Board: oldBoard, Board: currentBoard, Move: move)
         +boolean validateVacant(Board: board, Move: move)
        ' mb more
    }

    namespace model {
        namespace enums {

            enum Color {
                WHITE
                BLACK
            }

            enum Occupancy extends Color {
                WHITE
                BLACK
                EMPTY
            }

            enum BoardSize {
                NINE
                THIRTEEN
                NINETEEN
            }

            enum MoveType {
                MOVE
                PASS
            }

            enum ResponseStatus {
                OK
                INVALID_MOVE
                UNAUTHORIZED_MOVE
            }
        }

        class Board {

            fields : Occupancy[][]
            boardSize : BoardSize

            int getSize()
        }

        class Game {
            gameId : int
            boards : Board[]
            black : Player
            white : Player
            whoseTurn : Color

            +int getId()
            +Board[] getBoards()
        }

        class Coordinates {
            +x : int
            +y : int
        }

        class ActionDTO {
            +playerId : int
            +actionType : MoveType
            +cords : Coordinates
        }

        class Move {
            +player : Color
            +cords : Coordinates
        }

        class ResponseDTO {
            +status : ResponseStatus
            +changes : List<Change>
            +whitesCaptives : int
            +blacksCaptives : int
        }

        class Player {
            +playerId : int
            +amountOfCaptives : int
        }

        class Change {
            +occupancy : Occupancy
            +cords : Coordinates
        }

        MoveDTO "1" o-- "1" Move
        Move "1" *-- "1" core.model.enums.MoveType
        ResponseDTO "1" *-- "1" core.model.enums.ResponseStatus
        ResponseDTO "1" o-- "1...*" Change
        Change "1" *-- "1" core.model.enums.Occupancy
        Change "1" o-- "1" Coordinates
        Game "1" o-- "1, 2, 3" Board
        Game "1" o-- "2" Player
        Game "1" *-- "1" core.model.enums.Color
        Board "1" *-- "*" core.model.enums.Occupancy
        Board "1" *-- "1" core.model.enums.BoardSize
    }
}

namespace infrastructure {

    'albo zapis do pliku albo musi byc singleton
    class GameRepository implements core.interfaces.IGameRepository {
        -games : List<Game>

        +void cancelGame(int gameId, Color winner)
        +int createNewGame()
        +Board getBoard(int)
        +void updateBoard(int, List<Change>)
    }
}

namespace main {
    interface ICommunicationBase {

        +ResponseDTO orderMove(MoveDTO)
    }

    class CommunicationBase implements ICommunicationBase {

        -commandDirector : ICommandDirector

        +ResponseDTO orderMove(MoveDTO)
    }
    CommunicationBase ..> core.interfaces.ICommandDirector
}

'CommunicationBase --> "receives" MoveDTO
'CommunicationBase --> "sends" ResponseDTO
'CommunicationBaseImpl "1" o-- "1" Core
'CoreImpl "1" o-- "1" GameStore
'GameStoreImpl "1" o-- "0...*" Game



@enduml